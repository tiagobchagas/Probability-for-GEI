
# 
sessionInfo()
# Unload R packages
lapply(
        paste('package:',
              names(sessionInfo()$otherPkgs), sep = ""),
        detach,
        character.only = TRUE,
        unload = TRUE
)


## Density data generated plot ##

# Library
library(ggplot2)
library(reshape2)
library(rstan)
library(stringr)

# Reading output from stan (MET model)
setwd("/Users/tiagobchagas/Documents/ProgFeijaoUFV/ProgFeijaoUFV/Bayesiana/")
# Load
list.files()
load("BayesianaArq.RData")

##################################################################
print(names(out))
fit_summary <- summary(Model1)
print(names(fit_summary))
head(print(fit_summary$summary))
mean(fit_summary$summar[,"Rhat"])
mean(fit_summary$summar[,"n_eff"])/4000

# Seed
print(get_seed(Model1))
# The get_elapsed_time function returns a matrix 
# with the warmup and sampling times for each chain:
print(get_elapsed_time(Model1))
code <- get_stancode(Model1)
cat(code)
##################################################################

############ observed against generated data M4 ################

# Subset data generated by the model
data_plot <- data.frame(y = df_stan$y,
                        type = "Observed data")

data_plot_hat <- data.frame(y = c(y_gen_post),
                            type = "Generated data")

# Merge data
data_fig1 = rbind(data_plot, data_plot_hat)

x_lab <- "Adjusted means"
y_lab <- "Density"
#x_title <- ""
x_title <- "A: Observed against generated data"
(p1A <- ggplot(data_fig1, aes(x = y, colour = type)) + 
                geom_density() + 
                stat_density(geom = "line", position = "identity", show.legend = TRUE) +
                theme_bw() +
                scale_color_manual(values = c("#003350", "#cc662f")) +
                theme(axis.title.x = element_text(size = 11, face = "bold", color = "black"),
                      axis.title.y = element_text(size = 11, face = "bold", color = "black"),
                      axis.text.x  = element_text(size = 11, face = "bold", color = "black"),
                      axis.text.y  = element_text(size = 11, face = "bold", color = "black")) + 
                theme(plot.title = element_text(size = 11, hjust = 0.5, face = "bold")) + 
                theme(legend.title = element_blank(), 
                      legend.position = c(0.8, 0.80),
                      legend.text = element_text(face = "bold", size = 6.5)) +
                ylim(0, 0.15) + labs(x = x_lab, y = y_lab, title = x_title)) 

# Save Plot
ggsave(plot = p1A, filename = "p1A.tiff", device = "tiff", scale = 1, dpi = "retina")
ggsave(plot = p1A, filename = "p1A.png", width = 10,
       height = 5.5, device = "png", dpi = 250)

#####  Caterpillar describing the highest posterior density (HPD) interval of the estimated genetic values #####
library(ggmcmc)
library(coda)

# Changing the name of the hybrids:
#n_hyb = 36
dim(g_post)
colnames(g_post) = levels(df$H)
# Check Genotype order
all(gsub("H*", "", colnames(Z_3), perl = TRUE) == levels(df$H))

# PLots
x_lab <- "Genetic values"
y_lab <- "Families derived from Cycle III Recurrent Selection"
x_title <- "B: 95 % Highest posterior density interval"

# Plot 
(p1B <- ggs_caterpillar(ggs(as.mcmc(g_post))) +
        theme_bw() +
        theme(axis.title.x = element_text(size = 11, face = "bold", color = "black"), 
                axis.title.y = element_text(size = 11, face = "bold", color = "black"), 
                axis.text.x = element_text(size = 7, face = "bold", color = "black"), 
                axis.text.y = element_text(size = 6, face = "bold", color = "black")) + 
        theme(plot.title = element_text(size = 11, hjust = 0.5, face = "bold")) +
                labs(fill = legend, size = 12) +
        labs(x = x_lab, y = y_lab, title = x_title))

# Save Plot
ggsave(plot = p1B, filename = "p1B.tiff", device = "tiff", scale = 1, dpi = "retina")
#ggsave(plot = p1B, filename = "p1B.pdf", device = "pdf", scale = 2, dpi = "retina")

############## global stability ############

# Variables
n_g = nlevels(df$H)  # Genotype

# Index Matrix
ind_post = matrix(NA, nrow(g_post), ncol(g_post))
dim(ind_post)

# Loop for each environment
for (s in 1:nrow(g_post)){
        top20 = order(g_post[s,], decreasing = TRUE)[1:ceiling(0.2*length(g_post[s,]))]
        ind_post[s,top20]  = 1
        ind_post[s,-top20] = 0
}

##
# Prob Genotype Performance across Envs
prob_g = data.frame(ID = levels(df$H), prob_g = colMeans(ind_post))
prob_g = prob_g[order(prob_g$prob_g, decreasing = TRUE),]

# Changing order of the levels
prob_g$ID = factor(prob_g$ID, levels = prob_g$ID)

# 1 - Custom markers (left)
# note: shape = integer between 0 and 25
# note: stroke exists only for shapes between 1 and 24

x_lab <- "Families derived Cycle III Recurrent Selection"
y_lab <- "Probability of superior performance"
x_title <- "C: Marginal probability of superior performance"

# Plot 
(p1C = ggplot(prob_g, aes(x = ID, y = prob_g)) +
        geom_segment( aes(x = ID, xend = ID, y = 0, yend = prob_g), size = 1) +
        geom_point(size = 2, color = "red", fill = alpha("orange", 0.3), 
                   alpha = 0.7, shape = 21, stroke = 0.4) +
        theme_bw() +
        theme(axis.title.x = element_text(size = 11, face = "bold", color = "black"),
                axis.title.y = element_text(size = 11, face = "bold", color = "black"), 
                axis.text.x = element_text(size = 6, face = "bold", color = "black", angle = 90),
                axis.text.y = element_text(size = 7, face = "bold", color = "black")) + 
        theme(plot.title = element_text(size = 11, hjust = 0.5, face = "bold")) +
        labs(x = x_lab, y = y_lab, title = x_title))

# Save Plot
ggsave(plot = p1C, filename = "p1C.tiff", device = "tiff", scale = 1, dpi = "retina")
ggsave(plot = p1C, filename = "p1C.pdf", device = "pdf", scale = 2, dpi = "retina")
ggsave(plot = p1C, filename = "p1C.png", width = 10,
       height = 5.5, device = "png", dpi = 250)

######## PAIRWISE GLOBAL STABILITY ############

# Number of hybrids
n_hyb = 121

# All combinations
table <- matrix(NA, n_hyb, n_hyb)
dim(table)

# Loop
for(i in 1:ncol(g_post)){
        for(j in 1:ncol(g_post)){
                table[i,j] <- mean(g_post[,j] > g_post[,i])
        }
} # End

# Changing the name of the hybrids:
colnames(table) = levels(df$H)
rownames(table) = levels(df$H)
table[1:5, 1:5]

# Order the table according to genotype marginal effect
index <- data.frame(treat = 1:dim(g_post)[2], g_post = apply(g_post, 2, mean))
index <- index[order(index$g_post, decreasing = TRUE),]
index[1:5,]

# Order
diag(table) = NA
table <- table[c(index$treat),c(index$treat)]
table[1:5,1:5]

# Melting table:
table = melt(table)


x_lab <- "Families derived Cycle III Recurrent Selection"
y_lab <- "Families derived Cycle III Recurrent Selection"
x_title <- "D: Pairwise probability of superior performance"

# Plot
(p1D <- ggplot(table, aes(Var1, Var2)) +
        geom_tile(aes(fill = value), colour = "white") +
        scale_fill_gradientn(colours = rev(grDevices::rainbow(4, alpha = 1)), na.value = "white") +
        ylab('Hybrids') + xlab('Hybrids') +
        labs(fill = expression(bold(Pr(g[i] > g[j])))) +
        theme_bw() +
        theme(axis.text.x = element_text(size = 6, angle = 90, face = "bold", color = "black"),
                axis.title.y = element_text(size = 11, face = "bold", color = "black"), 
                axis.title.x = element_text(size = 11, face = "bold", color = "black"),
                axis.text.y = element_text(size = 6, face = "bold", color = "black")) +
        theme(plot.title = element_text(size = 11, hjust = 0.5, face = "bold"),
              legend.text = element_text(size = 10, face = "bold"),
              legend.title = element_text(size = 10, face = "bold")) +
        labs(x = x_lab, y = y_lab, title = x_title))

# Save Plot
ggsave(plot = p1D, filename = "p1D.tiff", device = "tiff", scale = 1, dpi = "retina")
ggsave(plot = p1D, filename = "p1D.pdf", device = "pdf", scale = 2, dpi = "retina")

# Plot Grid
library(gridExtra)
(p1_all <- grid.arrange(p1A, p1B, p1C, p1D))

# Save Grid Plot
#ggsave(plot = p1_all, filename = "p1_all.tiff", device = "tiff", scale = 2, dpi = 'retina')
ggsave(plot = p1_all, filename = "p1_all.pdf", device = "pdf", scale = 3, dpi = 'retina')




######### prob of performance within envs ###########

# Variables
n_g = nlevels(df$H)  # Genotype
n_l = nlevels(df$L)  # Environment
n_m = nlevels(df$M)  # Environment
n_sim = nrow(g_post) # Number of Monte Carlo simulations

# Indicator Matrix
ind_post = matrix(NA, n_sim, n_g)
dim(ind_post)

# Check order
all(gsub("*L", "", colnames(Z_4)) == levels(df$L))

# Combination of regions and locations:
#map = paste0(levels(df$M), "_", paste("E", 1:16, sep = ""))
map = paste0(rep(levels(df$M), times = c(3,2,4,4,3)), "_", paste("E", 1:16, sep = ""))
map

# Initialize matrix to receive the probabilities:
prob_stab_gge = matrix(NA, n_g, n_l)
rownames(prob_stab_gge) = levels(df$H)
colnames(prob_stab_gge) = levels(df$L)
dim(prob_stab_gge)
prob_stab_gge[1:2, 1:2]

# Initialize list to receive the indicators:
ind_list = list()
dim(g_post)

# Loop
for (s in 1:nrow(g_post)){
        # Creating a matrix with genotypes on the rows and regions on the columns:
        #GM = matrix(gm_post[s,], n_g)# n_m)
        #colnames(GM) = levels(df$M)
        # Initialize matrix to receive values:
        GGE = matrix(NA, n_g, n_l)
        rownames(GGE) = levels(df$H)
        colnames(GGE) = levels(df$L)
        for (m in 1:n_m) {
                # Subset the name of the region:  
                #subset = levels(df$M)[m]
                # Create mask to subset only the environments related to that specific region:
                #mask = str_detect(map, subset)
                # Sum GL nested on R with GR interaction:
                #GGE[,mask] = matrix(rep(g_post[s,], sum(mask)), ncol = sum(mask)) + 
                        m#atrix(gl_post[s,], n_g, n_l)[,mask] + matrix(GM[,subset], n_g, sum(mask))
              }
        for (k in 1:n_l) {
                # Initialize matrix:
                if (s==1) {
                        ind_list[[k]] = matrix(NA, n_sim, n_g)
                }
                # Building the indicators
                top20 = order(GGE[,k], decreasing = TRUE)[1:ceiling(0.2*length(GGE[,k]))]
                ind_list[[k]][s,top20]  = 1
                ind_list[[k]][s,-top20] = 0
        }
}

# Initialize matrix to receive the probabilities:
prob_stab_gge = matrix(NA, n_g, n_l)
rownames(prob_stab_gge) = levels(df$H)
colnames(prob_stab_gge) = levels(df$L)

# Compute the probabilities:
for (k in 1:n_l) {
        prob_stab_gge[,k] = colMeans(ind_list[[k]])
}
head(prob_stab_gge)

# Rordering matrix by the mean probability:
index = order(rowMeans(prob_stab_gge), decreasing = FALSE)
prob_stab_gge = prob_stab_gge[index,]
ordered_id = rownames(prob_stab_gge)
prob_stab_gge = data.frame(ID = rownames(prob_stab_gge), prob_stab_gge)
head(prob_stab_gge)


# Order by Env
index_env = c("ID", paste("E", 1:n_l, sep = ""))
        
prob_stab_gge = prob_stab_gge[,index_env]
head(prob_stab_gge)

# Melting table:
prob_stab_gge = melt(data.frame(prob_stab_gge[index,]))

# Changing order of the levels
prob_stab_gge$ID = factor(prob_stab_gge$ID, levels = ordered_id)

# Generating headmap

x_lab <- 'Environments'
y_lab <- 'Families derived Cycle III Recurrent Selection'
x_title <- "A: Probabilities of superior performance within environments"

# Plot
(p2A <- ggplot(prob_stab_gge, aes(variable, ID)) +
        geom_tile(aes(fill = value), colour = "white") +
        scale_fill_gradientn(colours = rev(grDevices::rainbow(3, alpha = 1)), 
                             na.value = "white", limits = c(0,1)) +
        labs(fill = expression(bold(Pr(g[jk] %in% Omega[k])))) +
        scale_x_discrete(position = "top") +
        theme(axis.title.x = element_text(size = 10, face = "bold", color = "black"),
                axis.title.y = element_text(size = 10, face = "bold", color = "black"), 
                axis.text.x = element_text(size = 8, face = "bold", color = "black"),
                axis.text.y = element_text(size = 6, face = "bold", color = "black")) +
        theme(plot.title = element_text(size = 10, hjust = 0.5, face = "bold")) +
        theme(legend.text = element_text(size = 10, face = "bold")) +
        theme(legend.title = element_text(size = 11, face = "bold")) +
        labs(x = NULL, y = y_lab, title = x_title))
        

# Save Plot                
ggsave(plot = p2A, filename = "p2A.tiff", device = "tiff", scale = 1, dpi = "retina")

######### prob of performance within region ###########

# Variables
n_g = nlevels(df$H)  # Genotype
n_l = nlevels(df$L)  # Environment
n_m = nlevels(df$M)  # Environment
n_sim = nrow(g_post) # Number of Monte Carlo simulations

# Initialize list to receive the indicators:
ind_list = list()

# Only GM Here

# Get indicators:
for(s in 1:n_sim){
        # Creating a matrix with genotypes on the rows and regions on the columns:
        GGM = matrix(rep(g_post[s,], n_m), ncol=n_m) #+ matrix(gm_post[s,], n_g, n_m)
        colnames(GGM) = levels(df$M)
        head(GGM)
        # Loop per region
        for(m in 1:n_m) {
                # Subset the name of the region:  
                subset = levels(df$M)[m]
               # Initialize matrix:
                if (s==1) {
                        ind_list[[subset]] = matrix(NA, n_sim, n_g)
                }
                # Building the indicators
                top20 = order(GGM[,subset], decreasing = TRUE)[1:ceiling(0.2*length(GGM[,subset]))]
                ind_list[[subset]][s,top20]  = 1
                ind_list[[subset]][s,-top20] = 0
        }
   }


# Initialize matrix to receive the probabilities:
prob_stab_ggm = matrix(NA, n_g) #n_m)
rownames(prob_stab_ggm) = levels(df$H)
colnames(prob_stab_ggm) = levels(df$M)

# Compute the probabilities:
for(m in levels(df$M)) {
        prob_stab_ggm[,m] = colMeans(ind_list[[m]])
}

# Rordering matrix by the mean probability:
index = order(rowMeans(prob_stab_ggm), decreasing = FALSE)
prob_stab_ggm = prob_stab_ggm[index,]
ordered_id = rownames(prob_stab_ggm)
prob_stab_ggm = data.frame(ID = rownames(prob_stab_ggm), prob_stab_ggm)

# Melting table:
prob_stab_ggm = melt(data.frame(prob_stab_ggm[index,]))

# Changing order of the levels
prob_stab_ggm$ID = factor(prob_stab_ggm$ID, levels = ordered_id)

# Generating headmap
x_lab <- 'Regions'
y_lab <- 'Hybrids'
x_title <- "B: Probabilities of superior performance within regions"

# Plot
(p2B <- ggplot(prob_stab_ggm, aes(variable, ID)) +
        geom_tile(aes(fill = value), colour = "white") +
        scale_fill_gradientn(colours = rev(grDevices::rainbow(3, alpha = 1)), 
                             na.value = "white", limits = c(0, 1)) +
        scale_x_discrete(position = "top") +
        labs(fill = expression(bold(Pr(g[jt] %in% Omega[t])))) +
        theme(axis.title.x = element_text(size = 10, face = "bold", color = "black"),
                axis.title.y = element_text(size = 10, face = "bold", color = "black"), 
                axis.text.x = element_text(size = 8, face = "bold", color = "black"),
                axis.text.y = element_text(size = 6, face = "bold", color = "black")) +
        theme(plot.title = element_text(size = 10, hjust = 0.5, face = "bold")) +
        theme(legend.text = element_text(size = 10, face = "bold")) +    
        labs(x = NULL, y = y_lab, title = x_title) +
        theme(legend.text = element_text(face = "bold")))

# Save Plot
ggsave(plot = p2B, filename = "p2B.tiff", device = "tiff", scale = 1, dpi = "retina")

# Plot GRID
library(gridExtra)
# Option 2
p2_all_2 <- grid.arrange(p2A, p2B, nrow = 2) 
#ggsave(plot = p2_all_2, filename = "p2_all_2.tiff", device = "tiff", scale = 2, dpi = 'retina')
ggsave(plot = p2_all_2, filename = "p2_all_2.pdf", device = "pdf", scale = 3, dpi = 'retina')



# ######### joint prob of performance and stability by regions - FIG 3A 
# 
# # Variables
# n_g = nlevels(df$H)  # Genotype
# n_l = nlevels(df$L)  # Environment
# n_m = nlevels(df$M)  # Environment
# n_sim = nrow(g_post) # Number of Monte Carlo simulations
# 
# # Index Matrix
# ind_post = matrix(NA, nrow(g_post), ncol(g_post))
# 
# # Loop for each environment
# for (s in 1:nrow(g_post)){
#         top20 = order(g_post[s,], decreasing = TRUE)[1:ceiling(0.2*length(g_post[s,]))]
#         ind_post[s,top20]  = 1
#         ind_post[s,-top20] = 0
# }
# 
# # Prob global stability:
# prob_g = data.frame(ID = levels(df$H), prob_g = colMeans(ind_post))
# prob_g
# 
# # Combination of regions and locations:
# map = unique(paste0(as.character(df$M), "_", as.character(df$L)))
# map
# 
# # Initialize list to receive the indicators:
# ind_list = list()
# 
# for (s in 1:nrow(g_post)){
#         for (m in 1:n_m) {
#                 # Subset the name of the region:  
#                 subset = levels(df$M)[m]
#                 # Create mask to subset only the environments related to that specific region:
#                 mask = str_detect(map, subset)
#                 # Sum GL nested on R with GR interaction:
#                 GE = matrix(gl_post[s,], n_g, n_l)[,mask] + 
#                         matrix(rep(matrix(gm_post[s,], n_g, n_m)[,m], sum(mask)), ncol=sum(mask))
#                 # Initialize matrix:
#                 if (s==1) {
#                         ind_list[[subset]] = matrix(NA, nrow(g_post), nrow(GE))
#                 }
#                 # Building the indicators
#                 var_GE = apply(GE,1,var)
#                 top20 = order(var_GE, decreasing = FALSE)[1:ceiling(0.2*length(var_GE))]
#                 ind_list[[subset]][s,top20]  = 1
#                 ind_list[[subset]][s,-top20] = 0
#         }
#    } # End
# 
# # Initialize matrix to receive the probabilities:
# prob_stab_gvar = matrix(NA, n_g, n_m)
# rownames(prob_stab_gvar) = levels(df$H)
# colnames(prob_stab_gvar) = levels(df$M)
# 
# # Compute the probabilities:
# for (m in levels(df$M)) {
#         prob_stab_gvar[,m] = colMeans(ind_list[[m]]) * prob_g$prob_g
# }
# 
# # Rordering matrix by the mean probability:
# index = order(rowMeans(prob_stab_gvar), decreasing = FALSE)
# prob_stab_gvar = prob_stab_gvar[index,]
# ordered_id = rownames(prob_stab_gvar)
# prob_stab_gvar = data.frame(ID = rownames(prob_stab_gvar), prob_stab_gvar)
# head(prob_stab_gvar)
# 
# # Melting table:
# prob_stab_gvar = melt(data.frame(prob_stab_gvar[index,]))
# 
# # Changing order of the levels
# prob_stab_gvar$ID = factor(prob_stab_gvar$ID, levels = ordered_id)
# 
# # Generating headmap
# 
# x_lab <- 'Regions'
# y_lab <- 'Hybrids'
# x_title <- "A: Joint probability of performance and stability by Regions"
# 
# # Plot
# (p3A <- ggplot(prob_stab_gvar, aes(variable, ID)) +
#         geom_tile(aes(fill = value), colour = "white") +
#         scale_fill_gradientn(colours = rev(grDevices::rainbow(3)), na.value = "white", 
#                              limits = c(0,0.4)) + 
#                 labs(fill = expression(bold(p(g[jt] %in% Omega[t])))) +
#                 scale_x_discrete(position = "top") +
#                 theme(axis.title.x = element_text(size = 9, face = "bold", color = "black"),
#                         axis.title.y = element_text(size = 9, face = "bold", color = "black"), 
#                         axis.text.x = element_text(size = 9, face = "bold", color = "black"),
#                         axis.text.y = element_text(size = 6, face = "bold", color = "black")) +
#                 theme(plot.title = element_text(size = 10, hjust = 0.5, face = "bold")) +
#                 theme(legend.text = element_text(size = 10, face = "bold")) +    
#                 labs(x = NULL, y = y_lab, title = x_title))
#                 
# # Save Plot
# ggsave(plot = p3A, filename = "p3A.tiff", device = "tiff", scale = 1, dpi = "retina")



########## ## Eskridge Risk #######################
# Yi. - Z(1 - \alpha)(Vi)^0.5
# Extract stan results
out_M1 <- rstan::extract(Model1, permuted = TRUE)
print(names(out_M1))

# MAP
get_map <- function(posterior){
        posterior <- as.matrix(posterior) 
        if (ncol(posterior) > 1) {
                den = apply(posterior, 2, density)
                map = unlist(lapply(den, function(den)
                        den$x[which.max(den$y)]))
        }
        else {
                den = density(posterior)
                map = den$x[which.max(den$y)]
        }
        return(map)
}

# Yi.
g_i = get_map(out_M1$g) #+ mean(df$GY)

# Vi
n_g = nlevels(df$H)  # Genotype
n_l = nlevels(df$L)  # Environment
g_l = get_map(out_M1$gl)
## g_m = get_map(out_M4$gm) # Entender melhor
GL = matrix(g_l, n_g, n_l)
Vi = apply(GL, 1, sd)

# Z(1 - \alpha) 
plot(density(g_post))
Z_ind = quantile(g_post, probs = 0.95)

## Risk Prob
Risk = round(g_i - (Z_ind*(Vi)),2)
Risk = data.frame(Risk, ID = paste("G", 1:121, sep = ""))
Risk = Risk[order(Risk$Risk, decreasing = TRUE),]

# Changing order of the levels
Risk$ID = factor(Risk$ID, levels = Risk$ID)

x_lab <- "Families derived Cycle III Recurrent Selection"
y_lab <- "Safety-first index"
x_title <- "A: Bayesian Eskridge Risk index"
dev.off()

# Plot 
(P3a = ggplot(Risk, aes(x = ID, y = Risk)) +
                geom_segment( aes(x = ID, xend = ID, y = 0, yend = Risk), size = 1) +
                geom_point(size = 2, color = "red", fill = alpha("orange", 0.3), 
                           alpha = 0.7, shape = 21, stroke = 0.4) +
                theme_bw() +
                theme(axis.title.x = element_text(size = 11, face = "bold", color = "black"),
                      axis.title.y = element_text(size = 11, face = "bold", color = "black"), 
                      axis.text.x = element_text(size = 6, face = "bold", color = "black", angle = 90),
                      axis.text.y = element_text(size = 7, face = "bold", color = "black")) + 
                theme(plot.title = element_text(size = 11, hjust = 0.5, face = "bold")) +
                labs(x = x_lab, y = y_lab, title = x_title))

# Save Plot
ggsave(plot = P3a, filename = "Risk.tiff", device = "tiff", scale = 2, dpi = "retina")
ggsave(plot = P3a, filename = "Risk.pd", device = "pdf", scale = 2, dpi = "retina")


######### Joint probability of performance and stability ###########

# Variables
n_g = nlevels(df$H)  # Genotype
n_l = nlevels(df$L)  # Environment
#n_m = nlevels(df$M)  # Environment
n_sim = nrow(g_post) # Number of Monte Carlo simulations

# Index Matrix
ind_post = matrix(NA, nrow(g_post), ncol(g_post))

# Loop for each environment
for (s in 1:nrow(g_post)){
        top20 = order(g_post[s,], decreasing = TRUE)[1:ceiling(0.2*length(g_post[s,]))]
        ind_post[s,top20]  = 1
        ind_post[s,-top20] = 0
}

# Prob of performance:
prob_g = data.frame(ID = levels(df$H), prob_g = colMeans(ind_post))
prob_g

# Combination of regions and locations:
map = unique(paste0( "_", as.character(df$L)))
map

# Loop per MCMC
for(s in 1:nrow(g_post)){
        # Creating a matrix with genotypes on the rows and regions on the columns:
       # GM = matrix(gm_post[s,], n_g, n_m)
        #colnames(GM) = levels(df$M)
        # Initialize matrix to receive values:
        GE = matrix(NA, n_g, n_l)
        # Loop per region
        for(m in 1:n_m) {
                # Subset the name of the region:  
                #subset = levels(df$M)[m]
                # Create mask to subset only the environments related to that specific region:
                #mask = str_detect(map, subset)
                # Sum GL nested on R with GR interaction:
              #  GE[,mask] = matrix(gl_post[s,], n_g, n_l)[,mask] + matrix(GM[,subset], n_g, sum(mask))
        }
        # Building the indicators
        var_GE = apply(GE,1,var)
        top20 = order(var_GE, decreasing = FALSE)[1:ceiling(0.2*length(var_GE))]
        ind_post[s,top20]  = 1
        ind_post[s,-top20] = 0
 }


# Prob Stability
prob_var = data.frame(ID = levels(df$H), prob_var = colMeans(ind_post))

# Prob Stability
prob_global_stab = data.frame(ID = levels(df$H), prob_var = prob_var$prob_var, prob_g = prob_g$prob_g, 
                              prob_global_stab = prob_g$prob_g*prob_var$prob_var)
head(prob_global_stab)  

# Order
prob_global_stab <- prob_global_stab[order(prob_global_stab$prob_global_stab, decreasing = TRUE),]
head(prob_global_stab)

# Changing order of the levels
prob_global_stab$ID = factor(prob_global_stab$ID, levels = prob_global_stab$ID)

# Melting data frame:
prob_global_stab = melt(prob_global_stab) # Using ID, variable, value as id variables
prob_global_stab
str(prob_global_stab)

# Colors
linecolors <- c("#c51b7d", "#4d4d4d", "#4d4d4d")
fillcolors <- c("#1b7837", "#d73027", "#313695")

x_lab <- 'Families derived Cycle III Recurrent Selection'
y_lab <- 'Probabilities'
x_title <- "B: Joint probability of superior performance and stability"


# Plot
# Procurar opaco no GGPLOT2
(p3B = ggplot(prob_global_stab, aes(x = ID, y = value, fill = variable)) +
        geom_segment(aes(x = ID, xend = ID, y = 0, yend = value), size = 1.3) +
        geom_point(aes(shape = variable), position = position_jitter(h = 0.01, w = 0.1), 
                   size = 2.5, color = "black", alpha = 1, shape = 21, stroke = 0.5) +
        theme_bw() +
        scale_color_manual(values = linecolors) + 
        scale_fill_manual(values = fillcolors, 
                          name = "Probabilities", 
                          labels = c(expression(bold(p(var(ge[jk]) %in% V))),
                                expression(bold(p(g[j] %in% Omega))), 
                                expression(bold(p(g[j] %in% Omega, var(ge[jk]) %in% V))),                                                       expression(bold(p(g[j] %subset% Omega, var(ge[jk]) %subset% V))))) +
        theme(legend.text.align = 0) +
        theme(axis.title.x = element_text(size = 9, face = "bold", color = "black"),
                axis.title.y = element_text(size = 9, face = "bold", color = "black"),
                axis.text.x = element_text(size = 7, face = "bold", color = "black", angle = 90),
                axis.text.y = element_text(size = 8, face = "bold", color = "black")) +
        theme(plot.title = element_text(size = 11, hjust = 0.5, face = "bold")) +
        theme(legend.text = element_text(face = "bold")) +    
        labs(x = x_lab, y = y_lab) +
        theme(legend.text = element_text(size = 7, face = "bold")) +
                theme(legend.title = element_text(face = "bold")))

# Save Plot
ggsave(plot = p3B,filename = "p3B.tiff", device = "tiff", scale = 2, dpi = "retina")
ggsave(plot = p3B,filename = "p3B.pdf", device = "pdf", scale = 2, dpi = "retina")



# Plot Grid
library(gridExtra)

p3_all_2 <- grid.arrange(P3a, p3B, nrow = 2)
ggsave(plot = p3_all_2, filename = "p3_all_2.tiff", device = "tiff", scale = 2, dpi = 'retina')
ggsave(plot = p3_all_2, filename = "p3_all_2.pdf", device = "pdf", scale = 3, dpi = 'retina')








